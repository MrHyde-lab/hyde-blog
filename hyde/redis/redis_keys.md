# Redis Keys总结归纳

### Keys

- **redis的keys使用二进制进行保存，这意味着可以使用“Hyde”这样的String类型甚至是JPEG的方式作为redis的key，同时空的String也是一个有效的key值。**

- **不建议使用很长的key(超过1024 bytes)，因为不仅仅会造成内存的浪费，还因为在数据集中查找键的时候还需要进行多次的键比较，这在效率至上的redis中是不合理的**

- **太短的key也是不合理的，如果你的键可以写成”user:hyde:dimash“，那么写成”uhd“是没有意义的，因为前者更具可读性，而且相比后者相比使用空间增加的也不多，虽然使用短的key会消耗更少的内存，但在工作中你需要找到一个适合自己的平衡点**

- **规范书写格式，”object_type:id“是一种较好的，规范如写成”user:1000,多词字段则可以使用.或者-进行隔开，如” "comment:4321:reply.to" or "comment:6666:reply-to“**

- **key允许的的最大长度为512MB**

- **EXISTS命令通过返回1或0来判断指定的键是否存在数据库中**

### Strings

- **String是redis中最简单的类型，也是内存缓存中的唯一类型**
- **由于redis中的key是String类型，因此当value也是String类型时，是在将一个字符串映射到另一个字符串。字符串的数据类型有很多使用场景，例如缓存HTML片段或者页面**
- **SET和GET是设置和检索String值的方式，如果一个key已经存在，即使它所关联的不是String值，使用SET也会将其覆盖**
- **String的值可以是各种字符，可以将jpeg存放在值中，但不能大于512MB**

### List

- **redis中的List是通过链表来实现的**

- **LPUSH命令是在链表头部插入元素，RPUSH是在尾部插入元素，LRANGE命令可以在指定范围内提取元素，LRANGE需要两个索引，一个是开始元素，另一个是最后元素，索引都可以是负数，如-1是告诉redis从最后一个元素开始，-2则是倒数第二个，以此类推**

- **List的应用场景：**
  
  - **可以用来保存用户发布到社交平台的最新更新，比如用户每次更新朋友圈时都会LPUSH此条信息的ID到List中**
  
  - **当用户访问主页时，可以通过LRANGE 0 9 来获取最新发布的10个项目**
  
  - **进程间的通信，应用于消费者-生产者模式，生产者将项目推送到列表中，消费者执行这些项目**

### Hash

- **Hash和我们平时所遇见的键值对完全一致**

- **Hash通常用于存储对象**

### Set

- **redis中的Set是无序的字符串集合，通过SADD将字符串添加如Set中**

- **Set应用场景：**
  
  - **Set可用于表达对象之间的关系，比如用Set来实现标签，比如标记一篇文章，用文章id作为value，使用各种标签对其进行关联**
  
  - **还可以通过这篇文章来反向检索它所拥有的标签**

### Sorted Set

- **Sorted Set是一种排序集，类似于Set和Hash的混合**

- **每一个元素都与一个被称为分数的浮点值相关联**

- **Sorted Set排序规则如下**
  
  - **如果 B 和 A 是具有不同分数的两个元素，则 A > B 如果 A.score > B.score。**
  
  - **如果 B 和 A 具有完全相同的分数，则如果 A 字符串在字典顺序上大于 B 字符串，则 A > B。 B 和 A 字符串不能相等，因为排序集只有唯一元素**




